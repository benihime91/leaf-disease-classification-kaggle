# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00a_lightning.core.ipynb (unless otherwise specified).

__all__ = ['params', 'CassavaLightningDataModule', 'model_hparams', 'cfg']

# Cell
from typing import Optional, Callable, Union, Dict
import albumentations as A
import pandas as pd

import torch
from torch import nn
import torch.nn.functional as F
from torch.utils.data import DataLoader, Dataset

import pytorch_lightning as pl
from pytorch_lightning.callbacks import Callback
from pytorch_lightning.metrics.functional.classification import accuracy
from pytorch_lightning import _logger as log

from ..core import *
from ..networks import *
from ..mixmethods import *

from hydra.utils import instantiate, call
from omegaconf import OmegaConf, DictConfig

# Cell
def params(m):
    "Return all parameters of `m`"
    return [p for p in m.parameters()]

# Cell
class CassavaLightningDataModule(pl.LightningDataModule):
    "lightning-datamodule for cassave leaf disease classification"
    def __init__(self, df_path:str, im_dir:str, curr_fold: int,
                 train_augs: A.Compose, valid_augs: A.Compose, bs: int = 64,
                 num_workers: int=0):

        super().__init__()
        self.df = load_dataset(df_path, im_dir, curr_fold, True)
        self.train_augs, self.valid_augs = train_augs, valid_augs
        self.bs, self.workers = bs, num_workers
        self.curr_fold = curr_fold
        self.im_dir = im_dir

    def prepare_data(self):
        log.info(f'DATA: {self.im_dir}')
        log.info(f'FOLD: {self.curr_fold}  BATCH_SIZE: {self.bs}')
        self.train_df: pd.DataFrame = self.df.loc[self.df['is_valid'] == False]
        self.valid_df: pd.DataFrame = self.df.loc[self.df['is_valid'] == True]

        self.train_df = self.train_df.reset_index(inplace=False, drop=True)
        self.valid_df = self.valid_df.reset_index(inplace=False, drop=True)

    def setup(self, stage=None):
        if stage == "fit" or stage is None:
            self.train_ds = ImageClassificationFromDf(self.train_df, self.train_augs)
            self.valid_ds = ImageClassificationFromDf(self.valid_df, self.valid_augs)
        if stage == "test" or stage is None:
            self.test_ds  = ImageClassificationFromDf(self.valid_df, self.valid_augs)

    def train_dataloader(self):
        return DataLoader(self.train_ds, shuffle=True, batch_size=self.bs, num_workers=self.workers)

    def val_dataloader(self):
        return DataLoader(self.valid_ds, batch_size=self.bs, num_workers=self.workers)

    def test_dataloader(self):
        return DataLoader(self.test_ds, batch_size=self.bs, num_workers=self.workers)

# Cell
model_hparams = dict(
    mixmethod = dict(_target_='src.mixmethods.SnapMix', alpha=5.0, conf_prob=1.0),
    loss_function = dict(_target_='src.core.LabelSmoothingCrossEntropy', eps=0.1),
    learning_rate = 1e-03,
    lr_mult = 100,
    optimizer = dict(_target_='src.opts.Ranger', weight_decay=1e-02, betas=(0.95, 0.999), eps=1e-05),
    scheduler = dict(_target_='src.opts.CosineAnnealingWarmupScheduler', warmup_epochs=2, total_epochs=10),
    metric_to_track = None,
    step_after = "epoch",
    frequency = 1,
)

cfg = OmegaConf.create(model_hparams)
print(OmegaConf.to_yaml(cfg))
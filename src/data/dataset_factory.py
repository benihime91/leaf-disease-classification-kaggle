# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01b_data.datasests_factory.ipynb (unless otherwise specified).

__all__ = ['create_transform', 'create_loader']

# Cell
import albumentations as A
import torchvision.transforms as T
from hydra.utils import instantiate
from omegaconf import DictConfig, OmegaConf
from torch.utils.data import DataLoader, Dataset

from src import _logger
from .datasets import CassavaDataset, load_data

# Cell
def create_transform(cfg: DictConfig, verbose=False):
    "creates transoformations to be used in datasets"
    train_augs_initial = [instantiate(t) for t in cfg.train.before_mix]
    train_augs_final   = [instantiate(t) for t in cfg.train.after_mix]
    valid_augs = [instantiate(t) for t in cfg.valid]

    if cfg.backend == "torchvision":
        compose_func = T.Compose
    elif cfg.backend == "albumentations":
        compose_func = A.Compose

    train_augs_initial = compose_func(train_augs_initial)
    train_augs_final   = compose_func(train_augs_final)
    valid_augs = compose_func(valid_augs)
    return train_augs_initial, train_augs_final, valid_augs

# Cell
def create_loader(cfg: DictConfig):
    "creates a `DataLoader's instance from Cfg`"
    ds_config = cfg.data.dataset
    tfm_config = cfg.augmentations
    dls_conf = cfg.data.dataloader

    transformations = create_transform(tfm_config)

    df = load_data(ds_config.csv, ds_config.image_dir,ds_config.fold, shuffle=True)

    trn_df = df.loc[df["is_valid"] == False]
    val_df = df.loc[df['is_valid'] == True]

    trn_df.reset_index(inplace=True, drop=True)
    val_df.reset_index(inplace=True, drop=True)

    _logger.info("Data processing configuration for current dataset:")
    _logger.info(f"\tinput_size: {cfg.input.input_size}")
    _logger.info(f"\tmean: {tuple(cfg.input.mean)}")
    _logger.info(f"\tstd: {tuple(cfg.input.std)}")
    _logger.info(f"\tinterpolation: {cfg.input.interpolation}")
    _logger.info("")

    trn_tfm, tfn_tfm_after, val_tfm = create_transform(tfm_config)

    if tfm_config.backend == "torchvision":
        trn_dset = CassavaDataset.from_torchvision_tfms(trn_df, fn_col="filePath",
                                                        label_col="label", transform=trn_tfm)

        val_dset = CassavaDataset.from_torchvision_tfms(val_df, fn_col="filePath",
                                                        label_col="label", transform=val_tfm)

    elif tfm_config.backend == "albumentations":
        trn_dset = CassavaDataset.from_albu_tfms(trn_df, fn_col="filePath",
                                                 label_col="label", transform=trn_tfm)

        val_dset = CassavaDataset.from_albu_tfms(val_df, fn_col="filePath",
                                                 label_col="label", transform=val_tfm)

    train_dl = DataLoader(trn_dset, shuffle=True, **dls_conf)
    val_dl = DataLoader(val_dset, shuffle=True, **dls_conf)

    return train_dl, val_dl, trn_dset, tfn_tfm_after
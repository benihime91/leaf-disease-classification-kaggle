# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_core.ipynb (unless otherwise specified).

__all__ = ['idx2lbl', 'conf_mat_idx2lbl', 'seed_everything', 'generate_random_id', 'load_dataset', 'DummyDataset',
           'ImageClassificationFromDf', 'params', 'trainable_params']

# Cell
import pandas as pd
import uuid
import numpy as np
import random
import os

import cv2
import albumentations as A
from albumentations.pytorch import ToTensorV2

import torch

pd.set_option('display.max_colwidth', None)

# Cell
idx2lbl = {
    0: "Cassava Bacterial Blight (CBB)",
    1: "Cassava Brown Streak Disease (CBSD)",
    2: "Cassava Green Mottle (CGM)",
    3: "Cassava Mosaic Disease (CMD)",
    4: "Healthy",
}



conf_mat_idx2lbl = {
    0: "CBB",
    1: "CBSD",
    2: "CGM",
    3: "CMD",
    4: "Healthy",
}

# Cell
def seed_everything(seed: int) -> int:
    """sets a seed for the environment in :
       `pytorch`, `numpy`, `python.random` and sets `PYTHONHASHSEED` environment variable.
    """
    random.seed(seed)
    os.environ['PYTHONHASHSEED'] = str(seed)
    np.random.seed(seed)
    torch.manual_seed(seed)
    torch.cuda.manual_seed(seed)
    torch.backends.cudnn.deterministic = True
    return seed

# Cell
def generate_random_id() -> str:
    "generates a random id"
    idx = uuid.uuid1()
    idx = str(idx).split("-")[0]
    return idx

# Cell
def load_dataset(pth: str, im_dir: str, curr_fold: int = 0, shuffle: bool = True) -> pd.DataFrame:
    "loads the dataframe and formats it"
    assert curr_fold < 5

    data = pd.read_csv(pth)

    data["filePath"] = [os.path.join(im_dir, data["image_id"][idx]) for idx in range(len(data))]
    data["is_valid"] = [data.kfold[n] == curr_fold for n in range(len(data))]
    data["label"].replace(idx2lbl, inplace=True)

    if shuffle: data = data.sample(frac=1).reset_index(drop=True, inplace=False)
    else      : data = data.reset_index(drop=True, inplace=False)

    return data

# Cell
class DummyDataset(torch.utils.data.Dataset):
    def __init__(self, data: pd.DataFrame):
        self.data = data

        self.transforms = A.Compose([A.RandomResizedCrop(224, 224, p=1.0),
                                     A.RandomBrightness(limit=0.1),
                                     A.VerticalFlip(),
                                     A.HorizontalFlip(),
                                     A.Normalize(p=1.0),
                                     ToTensorV2(p=1.0)])

        self.lbl_dict = {v: k for k, v in idx2lbl.items()}

    def __len__(self): return len(self.data)

    def __getitem__(self, index):
        image = self.data['filePath'][index]
        label = self.data['label'][index]

        image = cv2.imread(image)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

        image = self.transforms(image=image)['image']
        label = torch.tensor(self.lbl_dict[label])
        return image, label

# Cell
class ImageClassificationFromDf(torch.utils.data.Dataset):
    """
    Image classification dataset.
    Args:
        dataframe: dataframe with image_id and labels
        transformations: albumentation transformations
    """

    def __init__(self, dataframe: pd.DataFrame, transformations:A.Compose, lbl_dict:dict=None):
        self.df = dataframe
        self.transforms = transformations

        if lbl_dict is None: self.lbl_dict = {v: k for k, v in idx2lbl.items()}

    def __len__(self):
        return len(self.df)

    def __getitem__(self, idx):
        image_id = self.df['filePath'][idx]
        target = self.df['label'][idx]

        # Read an image with OpenCV
        img = cv2.imread(image_id)

        # By default OpenCV uses BGR color space for color images,
        # so we need to convert the image to RGB color space.
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

        # apply transformations to the image
        img = self.transforms(image=img)["image"]

        return img, torch.tensor(self.lbl_dict[target])

# Cell
def params(m):
    "Return all parameters of `m`"
    return [p for p in m.parameters()]

# Cell
def trainable_params(m):
    "Return all trainable parameters of `m`"
    return [p for p in m.parameters() if p.requires_grad]
# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_core.ipynb (unless otherwise specified).

__all__ = ['object_from_dict', 'idx2lbl', 'conf_mat_idx2lbl', 'seed_everything', 'generate_random_id', 'load_dataset',
           'DummyDataset', 'ImageClassificationFromDf', 'LabelSmoothingCrossEntropy']

# Cell
import pandas as pd
import uuid
import numpy as np
import random
import os

import cv2
import albumentations as A
from albumentations.pytorch import ToTensorV2

import torch
from torch.nn.modules.loss import _WeightedLoss
import torch.nn.functional as F
import pydoc

pd.set_option('display.max_colwidth', None)

# Cell
def object_from_dict(d, parent=None, **default_kwargs):
    kwargs = d.copy()
    object_type = kwargs.pop("type")
    for name, value in default_kwargs.items():
        kwargs.setdefault(name, value)

    if parent is not None:
        return getattr(parent, object_type)(**kwargs)  # skipcq PTC-W0034

    return pydoc.locate(object_type)(**kwargs)

# Cell
idx2lbl = {
    0: "Cassava Bacterial Blight (CBB)",
    1: "Cassava Brown Streak Disease (CBSD)",
    2: "Cassava Green Mottle (CGM)",
    3: "Cassava Mosaic Disease (CMD)",
    4: "Healthy",
}



conf_mat_idx2lbl = {
    0: "CBB",
    1: "CBSD",
    2: "CGM",
    3: "CMD",
    4: "Healthy",
}

# Cell
def seed_everything(seed: int) -> int:
    """sets a seed for the environment in :
       `pytorch`, `numpy`, `python.random` and sets `PYTHONHASHSEED` environment variable.
    """
    random.seed(seed)
    os.environ['PYTHONHASHSEED'] = str(seed)
    np.random.seed(seed)
    torch.manual_seed(seed)
    torch.cuda.manual_seed(seed)
    torch.backends.cudnn.deterministic = True
    return seed

# Cell
def generate_random_id() -> str:
    "generates a random id"
    idx = uuid.uuid1()
    idx = str(idx).split("-")[0]
    return idx

# Cell
def load_dataset(pth: str, im_dir: str, curr_fold: int = 0, shuffle: bool = True) -> pd.DataFrame:
    "loads the dataframe and formats it"
    assert curr_fold < 5

    data = pd.read_csv(pth)

    data["filePath"] = [os.path.join(im_dir, data["image_id"][idx]) for idx in range(len(data))]
    data["is_valid"] = [data.kfold[n] == curr_fold for n in range(len(data))]
    data["label"].replace(idx2lbl, inplace=True)

    if shuffle: data = data.sample(frac=1).reset_index(drop=True, inplace=False)
    else      : data = data.reset_index(drop=True, inplace=False)

    return data

# Cell
class DummyDataset(torch.utils.data.Dataset):
    def __init__(self, data: pd.DataFrame):
        self.data = data

        self.transforms = A.Compose([A.RandomResizedCrop(224, 224, p=1.0),
                                     A.RandomBrightness(),
                                     A.HorizontalFlip(),
                                     A.IAASharpen(),
                                     A.Normalize(p=1.0),
                                     ToTensorV2(p=1.0)])

        self.lbl_dict = {v: k for k, v in idx2lbl.items()}

    def __len__(self): return len(self.data)

    def __getitem__(self, index):
        image = self.data['filePath'][index]
        label = self.data['label'][index]

        image = cv2.imread(image)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

        image = self.transforms(image=image)['image']
        label = torch.tensor(self.lbl_dict[label])
        return image, label

# Cell
class ImageClassificationFromDf(torch.utils.data.Dataset):
    """
    Image classification dataset.
    Args:
        dataframe: dataframe with image_id and labels
        transformations: albumentation transformations
    """

    def __init__(self, dataframe: pd.DataFrame, transformations:A.Compose, lbl_dict:dict=None):
        self.df = dataframe
        self.transforms = transformations

        if lbl_dict is None: self.lbl_dict = {v: k for k, v in idx2lbl.items()}

    def __len__(self):
        return len(self.df)

    def __getitem__(self, idx):
        image_id = self.df['filePath'][idx]
        target = self.df['label'][idx]

        # Read an image with OpenCV
        img = cv2.imread(image_id)

        # By default OpenCV uses BGR color space for color images,
        # so we need to convert the image to RGB color space.
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

        # apply transformations to the image
        img = self.transforms(image=img)["image"]

        return img, torch.tensor(self.lbl_dict[target])

# Cell
class LabelSmoothingCrossEntropy(_WeightedLoss):
    "label smoothing loss"
    def __init__(self, eps:float=0.1, weight=None, reduction='mean'):
        super().__init__(weight=weight, reduction=reduction)
        self.weight = weight
        self.reduction = reduction
        self.eps = eps
    def forward(self, output, target):
        c = output.size()[-1]
        log_preds = F.log_softmax(output, dim=-1)
        if self.reduction=='sum':
            loss = -log_preds.sum()
        else:
            loss = -log_preds.sum(dim=-1)
            if self.reduction=='mean':
                loss = loss.mean()
        return loss*self.eps/c + (1-self.eps) * F.nll_loss(log_preds, target.long(), reduction=self.reduction)